# -*- coding: utf-8 -*-
"""Xception_ EfficientNetB0Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FAIfKvqA43QUmhzH_JlEAtni8es5zToZ

# COVID19 CHest X-Ray Detector

### When using in Google Colab, mounts Google Drive to access the data
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %cd '/content/drive/My Drive/COVID_Chest_X_Ray_Data/COVID19-Data'

from google.colab import files
Pneumonia = files.upload()
Normal = files.upload()

!unzip "/content/G_NC.zip"

!unzip "/content/G_PC.zip"

"""### Importing all dependencies and libraries"""

from __future__ import print_function, division
from builtins import range, input

from tensorflow.keras.layers import Input, Lambda, Dense, Flatten, GlobalAveragePooling2D, Dropout
from tensorflow.keras.models import Model, load_model

from tensorflow.keras.applications import Xception
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.applications import VGG19
from tensorflow.keras.applications.vgg16 import preprocess_input
from tensorflow.keras.preprocessing import image
from tensorflow.keras.preprocessing.image import ImageDataGenerator

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelBinarizer
from tensorflow.keras.utils import to_categorical

from sklearn.metrics import classification_report

from sklearn.metrics import confusion_matrix, roc_curve
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt


from sklearn.model_selection import StratifiedKFold

from glob import glob
import pandas as pd

"""### Defines some model parameters"""





#define size to which images are to be resized
IMAGE_SIZE = [224, 224] # can be changed depending on the dataset

# training config:
epochs = 250
batch_size = 32

# define paths
# Pneumonia_path = '/content/drive/My Drive/COVID_Chest_X_Ray_Data/Chest_COVID'
# Normal_path = '/content/drive/My Drive/COVID_Chest_X_Ray_Data/Chest_NonCOVID'
Pneumonia_path = '/content/G2'
Normal_path = '/content/G1'
# Use glob to grab images from path .jpg or jpeg
Pneumonia_files = glob(Pneumonia_path + '/*')
Normal_files = glob(Normal_path + '/*')

# Data size for both of the labels

print(len(Pneumonia_files), len(Normal_files))

# Preparing Labels
Pneumonia_labels = []
Normal_labels = []

Pneumonia_images=[]
Normal_images=[]

import cv2 

for i in range(500):
  image = cv2.imread(Pneumonia_files[i])
  image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
  image = cv2.resize(image,(224,224))
  Pneumonia_images.append(image )
  Pneumonia_labels.append('Chest_Pneumonia')
  
for i in range(500):
  image = cv2.imread(Normal_files[i])
  image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
  image = cv2.resize(image,(224,224))
  Normal_images.append(image )
  Normal_labels.append('Chest_Normal')

# # Preparing Labels
# Pneumonia_labels = []
# Normal_labels = []

# Pneumonia_images=[]
# Normal_images=[]

# import cv2 

# for i in range(len(Pneumonia_files)):
#   image = cv2.imread(Pneumonia_files[i])
#   image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
#   image = cv2.resize(image,(224,224))
#   Pneumonia_images.append(image)
#   Pneumonia_labels.append('Chest_Pneumonia')
  
# for i in range(len(Normal_files)):
#   image = cv2.imread(noncovid_files[i])
#   image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
#   image = cv2.resize(image,(224,224))
#   Normal_images.append(image)
#   Normal_labels.append('Chest_NonCOVID')



"""### Quick glimpse of the data set"""

# look at a random image for fun
def plot_images(images, title):
    nrows, ncols = 5, 8
    figsize = [10, 6]

    fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize, facecolor=(1, 1, 1))

    for i, axi in enumerate(ax.flat):
        axi.imshow(images[i])
        axi.set_axis_off()

    plt.suptitle(title, fontsize=24)
    plt.tight_layout(pad=0.2, rect=[0, 0, 1, 0.9])
    plt.show()
plot_images(Pneumonia_images, 'Pneumonia Chest X-ray')
plot_images(Normal_images, 'Normal Chest X-ray')

# Convert to array and Normalize to interval of [0,1]
Pneumonia_images = np.array(Pneumonia_images) / 255

# np.save('covid_images', covid_images)

len(Normal_images)

# covid_images  = np.load("/content/covid_images.npy")

Normal_images

Normal_images = np.array(Normal_images) / 255

"""### Split data set into training and testing"""

from sklearn.model_selection import KFold
inputs = np.concatenate((Pneumonia_images, Normal_images), axis=0)
targets = np.concatenate((Pneumonia_labels, Normal_labels), axis=0)

targets = LabelBinarizer().fit_transform(targets)
targets = to_categorical(targets)

# split into training and testing
Pneumonia_x_train, Pneumonia_x_test, Pneumonia_y_train, Pneumonia_y_test = train_test_split(Pneumonia_images, Pneumonia_labels, test_size=0.2)
Normal_x_train, Normal_x_test, Normal_y_train, Normal_y_test = train_test_split(Normal_images, Normal_labels, test_size=0.2)


X_train = np.concatenate((Normal_x_train, Pneumonia_x_train), axis=0)
X_test = np.concatenate((Normal_x_test, Pneumonia_x_test), axis=0)
y_train = np.concatenate((Normal_y_train, Pneumonia_y_train), axis=0)
y_test = np.concatenate((Normal_y_test, Pneumonia_y_test), axis=0)

# make labels into categories - either 0 or 1
y_train = LabelBinarizer().fit_transform(y_train)
y_train = to_categorical(y_train)

y_test = LabelBinarizer().fit_transform(y_test)
y_test = to_categorical(y_test)

plot_images(Pneumonia_x_train, 'X_train')
plot_images(Pneumonia_x_test, 'X_test')
# y_train and y_test contain class lables 0 and 1 representing COVID and NonCOVID for X_train and X_test

"""### Importing the Model"""

XceptionModel = Xception(weights="imagenet", include_top=False,
    input_tensor=Input(shape=(224, 224, 3)))

outputs = XceptionModel.output
outputs = Flatten(name="flatten")(outputs)
outputs = Dropout(0.5)(outputs)
outputs = Dense(2, activation="softmax")(outputs)

model = Model(inputs=XceptionModel.input, outputs=outputs)

for layer in XceptionModel.layers:
    layer.trainable = False

model.compile(
        loss='categorical_crossentropy', 
        optimizer='adam', 
        metrics=['accuracy']
)

model.summary()

train_augmented = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True
)

"""### Training!"""

history = model.fit(train_augmented.flow(X_train, y_train, batch_size=32),
                    validation_data=(X_test, y_test),
                    validation_steps=len(X_test) / 32,
                    steps_per_epoch=len(X_train) / 32,
                    epochs=250)

"""### Model export"""

model.save('/content/Xception_chest.h5')



model.save_weights('/content/Pneumonia_Xception_chest_weights.hdf5')

model = load_model('/content/Xception_chest.h5')

"""### Results and analysis"""

y_pred = model.predict(X_test, batch_size=batch_size)

y_pred[0:10]

prediction=y_pred[0:10]
for index, probability in enumerate(prediction):
    if probability[1] > 0.5:
        plt.title('%.2f' % (probability[1]*100) + '% Pneumonia')
    else:
        plt.title('%.2f' % ((1-probability[1])*100) + '% Normal')
    plt.imshow(X_test[index])
    plt.show()

# Convert to Binary classes
y_pred_bin = np.argmax(y_pred, axis=1)
y_test_bin = np.argmax(y_test, axis=1)

fpr, tpr, thresholds = roc_curve(y_test_bin, y_pred_bin)
plt.plot(fpr, tpr)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.0])
plt.rcParams['font.size'] = 12
plt.title('ROC curve for our model')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.grid(True)

def plot_confusion_matrix(normalize):
    classes = ['Pneumonia','Normal']
    tick_marks = [0.5,1.5]
    cn = confusion_matrix(y_test_bin, y_pred_bin,normalize=normalize)
    sns.heatmap(cn,cmap='plasma',annot=True)
    plt.xticks(tick_marks, classes)
    plt.yticks(tick_marks, classes)
    plt.title('Confusion Matrix')
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.show()

print('Confusion Matrix without Normalization')
plot_confusion_matrix(normalize=None)

print('Confusion Matrix with Normalized Values')
plot_confusion_matrix(normalize='true')

print(classification_report(y_test_bin, y_pred_bin))

plt.figure(figsize=(10,10))

plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])

plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')

plt.legend(['Training', 'Testing'])
plt.savefig('vgg_chest_accuracy.png')
plt.show()

plt.figure(figsize=(10,10))

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])

plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')

plt.legend(['Training', 'Testing'])
plt.savefig('vgg_chest_loss.png')
plt.show()

"""#5- fold"""





fold_no = 1
batch_size = 5
epochs = 25

acc_per_fold = []
perf_per_fold = []

# Define the K-fold Cross Validator
kfold = KFold(n_splits=5, shuffle=True)

for train, test in kfold.split(inputs, targets):
    
    #Create Model
  XceptionModel = Xception(weights="imagenet", include_top=False,
    input_tensor=Input(shape=(224, 224, 3)))

  outputs = XceptionModel.output
  outputs = Flatten(name="flatten")(outputs)
  outputs = Dropout(0.5)(outputs)
  outputs = Dense(2, activation="softmax")(outputs)

  model = Model(inputs=XceptionModel.input, outputs=outputs)

  for layer in XceptionModel.layers:
    layer.trainable = False

  model.compile(
        loss='categorical_crossentropy', 
        optimizer='adam', 
        metrics=['accuracy']
  )
    
  train_augmented = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True
  )
  history = model.fit(train_augmented.flow(inputs[train], targets[train], batch_size=32),
                    validation_data=(inputs[test], targets[test]),
                    validation_steps=len(inputs[test]) / 32,
                    steps_per_epoch=len(inputs[train]) / 32,
                    epochs=250)
  y_pred = model.predict(inputs[test], batch_size=batch_size)
  prediction=y_pred[0:10]
  for index, probability in enumerate(prediction):
    if probability[1] > 0.5:
        plt.title('%.2f' % (probability[1]*100) + '% Pneumonia')
    else:
        plt.title('%.2f' % ((1-probability[1])*100) + '% Normal')
    plt.imshow(inputs[test][index])
    plt.show()
  # Convert to Binary classes
  y_pred_bin = np.argmax(y_pred, axis=1)
  y_test_bin = np.argmax(targets[test], axis=1)
  
  
  fpr, tpr, thresholds = roc_curve(y_test_bin, y_pred_bin)
  plt.plot(fpr, tpr)
  plt.xlim([0.0, 1.0])
  plt.ylim([0.0, 1.0])
  plt.rcParams['font.size'] = 12
  plt.title('ROC curve for our model')
  plt.xlabel('False Positive Rate')
  plt.ylabel('True Positive Rate')
  plt.grid(True)


  def plot_confusion_matrix(normalize):
    classes = ['Pneumonia','Normal']
    tick_marks = [0.5,1.5]
    cn = confusion_matrix(y_test_bin, y_pred_bin,normalize=normalize)
    sns.heatmap(cn,cmap='plasma',annot=True)
    plt.xticks(tick_marks, classes)
    plt.yticks(tick_marks, classes)
    plt.title('Confusion Matrix')
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.show()

  print('Confusion Matrix without Normalization')
  plot_confusion_matrix(normalize=None)

  print('Confusion Matrix with Normalized Values')
  plot_confusion_matrix(normalize='true')


  print(classification_report(y_test_bin, y_pred_bin))



"""#EfficientNetB0

import model
"""

EfficientNetB0Model = EfficientNetB0(weights="imagenet", include_top=False,
    input_tensor=Input(shape=(224, 224, 3)))

outputs = EfficientNetB0Model.output
outputs = Flatten(name="flatten")(outputs)
outputs = Dropout(0.5)(outputs)
outputs = Dense(2, activation="softmax")(outputs)

model2 = Model(inputs=EfficientNetB0Model.input, outputs=outputs)

for layer in EfficientNetB0Model.layers:
    layer.trainable = False

model2.compile(
        loss='categorical_crossentropy', 
        optimizer='adam', 
        metrics=['accuracy']
)

model2.summary()

train_augmented = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True
)

"""Training"""



history = model2.fit(train_augmented.flow(X_train, y_train, batch_size=32),
                    validation_data=(X_test, y_test),
                    validation_steps=len(X_test) / 32,
                    steps_per_epoch=len(X_train) / 32,
                    epochs=250)

model2.save('/content/EfficientNetB0_chest.h5')

model2.save_weights('/content/EfficientNetB0_chest_weights.hdf5')

model2 = load_model('/content/EfficientNetB0_chest.h5')

"""Results and analysis"""

y_pred = model2.predict(X_test, batch_size=batch_size)

y_pred[0:10]

prediction=y_pred[0:10]
for index, probability in enumerate(prediction):
    if probability[1] > 0.5:
        plt.title('%.2f' % (probability[1]*100) + '% Pneumonia')
    else:
        plt.title('%.2f' % ((1-probability[1])*100) + '% Normal')
    plt.imshow(X_test[index])
    plt.show()

# Convert to Binary classes
y_pred_bin = np.argmax(y_pred, axis=1)
y_test_bin = np.argmax(y_test, axis=1)

fpr, tpr, thresholds = roc_curve(y_test_bin, y_pred_bin)
plt.plot(fpr, tpr)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.0])
plt.rcParams['font.size'] = 12
plt.title('ROC curve for our model')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.grid(True)

def plot_confusion_matrix(normalize):
    classes = ['Pneumonia','Normal']
    tick_marks = [0.5,1.5]
    cn = confusion_matrix(y_test_bin, y_pred_bin,normalize=normalize)
    sns.heatmap(cn,cmap='plasma',annot=True)
    plt.xticks(tick_marks, classes)
    plt.yticks(tick_marks, classes)
    plt.title('Confusion Matrix')
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.show()

print('Confusion Matrix without Normalization')
plot_confusion_matrix(normalize=None)

print('Confusion Matrix with Normalized Values')
plot_confusion_matrix(normalize='true')

print(classification_report(y_test_bin, y_pred_bin))

plt.figure(figsize=(10,10))

plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])

plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')

plt.legend(['Training', 'Testing'])
plt.savefig('vgg_chest_accuracy.png')
plt.show()

plt.figure(figsize=(10,10))

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])

plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')

plt.legend(['Training', 'Testing'])
plt.savefig('vgg_chest_loss.png')
plt.show()

"""5-fold"""

fold_no = 1
batch_size = 5
epochs = 25

acc_per_fold = []
perf_per_fold = []

# Define the K-fold Cross Validator
kfold = KFold(n_splits=5, shuffle=True)

for train, test in kfold.split(inputs, targets):
    
  EfficientNetB0Model = EfficientNetB0(weights="imagenet", include_top=False,
  input_tensor=Input(shape=(224, 224, 3)))

  outputs = EfficientNetB0Model.output
  outputs = Flatten(name="flatten")(outputs)
  outputs = Dropout(0.5)(outputs)
  outputs = Dense(2, activation="softmax")(outputs)

  model2 = Model(inputs=EfficientNetB0Model.input, outputs=outputs)

  for layer in EfficientNetB0Model.layers:
      layer.trainable = False


  model2.compile(
            loss='categorical_crossentropy', 
            optimizer='adam', 
            metrics=['accuracy']
  )
  train_augmented = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True
  )
  history = model2.fit(train_augmented.flow(inputs[train], targets[train], batch_size=32),
                    validation_data=(inputs[test], targets[test]),
                    validation_steps=len(inputs[test]) / 32,
                    steps_per_epoch=len(inputs[train]) / 32,
                    epochs=250)
  y_pred = model2.predict(inputs[test], batch_size=batch_size)
  prediction=y_pred[0:10]
  for index, probability in enumerate(prediction):
    if probability[1] > 0.5:
        plt.title('%.2f' % (probability[1]*100) + '% Pneumonia')
    else:
        plt.title('%.2f' % ((1-probability[1])*100) + '% Normal')
    plt.imshow(inputs[test][index])
    plt.show()
  # Convert to Binary classes
  y_pred_bin = np.argmax(y_pred, axis=1)
  y_test_bin = np.argmax(targets[test], axis=1)
  
  
  fpr, tpr, thresholds = roc_curve(y_test_bin, y_pred_bin)
  plt.plot(fpr, tpr)
  plt.xlim([0.0, 1.0])
  plt.ylim([0.0, 1.0])
  plt.rcParams['font.size'] = 12
  plt.title('ROC curve for our model')
  plt.xlabel('False Positive Rate')
  plt.ylabel('True Positive Rate')
  plt.grid(True)


  def plot_confusion_matrix(normalize):
    classes = ['Pneumonia','Normal']
    tick_marks = [0.5,1.5]
    cn = confusion_matrix(y_test_bin, y_pred_bin,normalize=normalize)
    sns.heatmap(cn,cmap='plasma',annot=True)
    plt.xticks(tick_marks, classes)
    plt.yticks(tick_marks, classes)
    plt.title('Confusion Matrix')
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.show()

  print('Confusion Matrix without Normalization')
  plot_confusion_matrix(normalize=None)

  print('Confusion Matrix with Normalized Values')
  plot_confusion_matrix(normalize='true')


  print(classification_report(y_test_bin, y_pred_bin))